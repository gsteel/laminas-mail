{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-mail üá∑üá∫ –†—É—Å—Å–∫–∏–º –≥—Ä–∞–∂–¥–∞–Ω–∞–º –ú—ã, —É—á–∞—Å—Ç–Ω–∏–∫–∏ Laminas, —Ä–æ–¥–∏–ª–∏—Å—å –∏ –∂–∏–≤–µ–º –≤ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∞—Ö. –£ –º–Ω–æ–≥–∏—Ö –∏–∑ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏ –∏ –∫–æ–ª–ª–µ–≥–∏ –∫–∞–∫ –≤ –†–æ—Å—Å–∏–∏, —Ç–∞–∫ –∏ –≤ –£–∫—Ä–∞–∏–Ω–µ. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å —Ä–æ–¥–∏–ª–∏—Å—å –≤ –†–æ—Å—Å–∏–∏. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å –∂–∏–≤—É—Ç –≤ –†–æ—Å—Å–∏–∏. –£ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∞–±—É—à–∫–∏ –∏ –¥–µ–¥—É—à–∫–∏ —Å—Ä–∞–∂–∞–ª–∏—Å—å —Å —Ñ–∞—à–∏—Å—Ç–∞–º–∏ –≤–æ –í—Ç–æ—Ä–æ–π –º–∏—Ä–æ–≤–æ–π –≤–æ–π–Ω–µ. –ó–¥–µ—Å—å –Ω–∏–∫—Ç–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ñ–∞—à–∏–∑–º. –£ –æ–¥–Ω–æ–≥–æ –∏–∑ –Ω–∞—Å –µ—Å—Ç—å —É–∫—Ä–∞–∏–Ω—Å–∫–∞—è —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏—Ü–∞, –∫–æ—Ç–æ—Ä–∞—è —Å–ø–∞—Å–ª–∞—Å—å –∏–∑ –¥–æ–º–∞ –≤–º–µ—Å—Ç–µ —Å —Å—ã–Ω–æ–º. –ü–æ–µ–∑–¥ –∑–∞–¥–µ—Ä–∂–∞–ª—Å—è –∏–∑-–∑–∞ –±–æ–º–±–µ–∂–∫–∏ –Ω–∞ –¥–æ—Ä–æ–≥–µ –≤–ø–µ—Ä–µ–¥–∏. –£ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä—è—á—É—Ç—Å—è –≤ –±–æ–º–±–æ—É–±–µ–∂–∏—â–∞—Ö. –ú—ã —Å —Ç—Ä–µ–≤–æ–≥–æ–π –∂–¥–µ–º –≤–µ—Å—Ç–æ—á–∫–∏ –æ—Ç –Ω–∏—Ö –ø–æ—Å–ª–µ –≤–æ–∑–¥—É—à–Ω—ã—Ö –Ω–∞–ª–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –±–µ—Å–ø–æ—Ä—è–¥–æ—á–Ω–æ –Ω–∞–Ω–æ—Å—è—Ç —É–¥–∞—Ä—ã –∏ –ø–æ–ø–∞–¥–∞—é—Ç –ø–æ –±–æ–ª—å–Ω–∏—Ü–∞–º, —à–∫–æ–ª–∞–º, –¥–µ—Ç—Å–∫–∏–º —Å–∞–¥–∞–º –∏ –¥–æ–º–∞–º. –ú—ã –Ω–µ –±–µ—Ä–µ–º —ç—Ç–æ –∏–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –°–ú–ò. –ú—ã –Ω–∞–±–ª—é–¥–∞–µ–º —ç—Ç–æ –Ω–∞–ø—Ä—è–º—É—é. –í—ã –¥–æ–≤–µ—Ä—è–µ—Ç–µ –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, —á—Ç–æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏ –º—ã –ø—Ä–æ—Å–∏–º –≤–∞—Å –¥–æ–≤–µ—Ä–∏—Ç—å—Å—è –Ω–∞–º –≤–Ω–æ–≤—å. –ú—ã –Ω—É–∂–¥–∞–µ–º—Å—è –≤ –ø–æ–º–æ—â–∏. –í—ã—Ö–æ–¥–∏—Ç–µ –∏ –ø—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –ø—Ä–æ—Ç–∏–≤ —ç—Ç–æ–π –±–µ—Å–ø–æ–ª–µ–∑–Ω–æ–π –≤–æ–π–Ω—ã. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫—Ä–æ–≤–æ–ø—Ä–æ–ª–∏—Ç–∏–µ. –°–∫–∞–∂–∏—Ç–µ \"–ù–µ—Ç –≤–æ–π–Ω–µ!\" üá∫üá∏ To Citizens of Russia We at Laminas come from all over the world. Many of us have friends, family and colleagues in both Russia and Ukraine. Some of us were born in Russia. Some of us currently live in Russia. Some have grandparents who fought Nazis in World War II. Nobody here supports fascism. One team member has a Ukrainian relative who fled her home with her son. The train was delayed due to bombing on the road ahead. We have friends who are hiding in bomb shelters. We anxiously follow up on them after the air raids, which indiscriminately fire at hospitals, schools, kindergartens and houses. We're not taking this from any media. These are our actual experiences. You trust us enough to use our software. We ask that you trust us to say the truth on this. We need your help. Go out and protest this unnecessary war. Stop the bloodshed. Say \"stop the war!\" Laminas\\Mail provides generalized functionality to compose and send both text and MIME-compliant multipart email messages. Mail can be sent with Laminas\\Mail via the Mail\\Transport\\Sendmail , Mail\\Transport\\Smtp or the Mail\\Transport\\File transport. Of course, you can also implement your own transport by implementing the Mail\\Transport\\TransportInterface . File issues at https://github.com/laminas/laminas-mail/issues Documentation is at https://docs.laminas.dev/laminas-mail/","title":"Home"},{"location":"#laminas-mail","text":"","title":"laminas-mail"},{"location":"#_1","text":"–ú—ã, —É—á–∞—Å—Ç–Ω–∏–∫–∏ Laminas, —Ä–æ–¥–∏–ª–∏—Å—å –∏ –∂–∏–≤–µ–º –≤ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∞—Ö. –£ –º–Ω–æ–≥–∏—Ö –∏–∑ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏ –∏ –∫–æ–ª–ª–µ–≥–∏ –∫–∞–∫ –≤ –†–æ—Å—Å–∏–∏, —Ç–∞–∫ –∏ –≤ –£–∫—Ä–∞–∏–Ω–µ. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å —Ä–æ–¥–∏–ª–∏—Å—å –≤ –†–æ—Å—Å–∏–∏. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å –∂–∏–≤—É—Ç –≤ –†–æ—Å—Å–∏–∏. –£ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∞–±—É—à–∫–∏ –∏ –¥–µ–¥—É—à–∫–∏ —Å—Ä–∞–∂–∞–ª–∏—Å—å —Å —Ñ–∞—à–∏—Å—Ç–∞–º–∏ –≤–æ –í—Ç–æ—Ä–æ–π –º–∏—Ä–æ–≤–æ–π –≤–æ–π–Ω–µ. –ó–¥–µ—Å—å –Ω–∏–∫—Ç–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ñ–∞—à–∏–∑–º. –£ –æ–¥–Ω–æ–≥–æ –∏–∑ –Ω–∞—Å –µ—Å—Ç—å —É–∫—Ä–∞–∏–Ω—Å–∫–∞—è —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏—Ü–∞, –∫–æ—Ç–æ—Ä–∞—è —Å–ø–∞—Å–ª–∞—Å—å –∏–∑ –¥–æ–º–∞ –≤–º–µ—Å—Ç–µ —Å —Å—ã–Ω–æ–º. –ü–æ–µ–∑–¥ –∑–∞–¥–µ—Ä–∂–∞–ª—Å—è –∏–∑-–∑–∞ –±–æ–º–±–µ–∂–∫–∏ –Ω–∞ –¥–æ—Ä–æ–≥–µ –≤–ø–µ—Ä–µ–¥–∏. –£ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä—è—á—É—Ç—Å—è –≤ –±–æ–º–±–æ—É–±–µ–∂–∏—â–∞—Ö. –ú—ã —Å —Ç—Ä–µ–≤–æ–≥–æ–π –∂–¥–µ–º –≤–µ—Å—Ç–æ—á–∫–∏ –æ—Ç –Ω–∏—Ö –ø–æ—Å–ª–µ –≤–æ–∑–¥—É—à–Ω—ã—Ö –Ω–∞–ª–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –±–µ—Å–ø–æ—Ä—è–¥–æ—á–Ω–æ –Ω–∞–Ω–æ—Å—è—Ç —É–¥–∞—Ä—ã –∏ –ø–æ–ø–∞–¥–∞—é—Ç –ø–æ –±–æ–ª—å–Ω–∏—Ü–∞–º, —à–∫–æ–ª–∞–º, –¥–µ—Ç—Å–∫–∏–º —Å–∞–¥–∞–º –∏ –¥–æ–º–∞–º. –ú—ã –Ω–µ –±–µ—Ä–µ–º —ç—Ç–æ –∏–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –°–ú–ò. –ú—ã –Ω–∞–±–ª—é–¥–∞–µ–º —ç—Ç–æ –Ω–∞–ø—Ä—è–º—É—é. –í—ã –¥–æ–≤–µ—Ä—è–µ—Ç–µ –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, —á—Ç–æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏ –º—ã –ø—Ä–æ—Å–∏–º –≤–∞—Å –¥–æ–≤–µ—Ä–∏—Ç—å—Å—è –Ω–∞–º –≤–Ω–æ–≤—å. –ú—ã –Ω—É–∂–¥–∞–µ–º—Å—è –≤ –ø–æ–º–æ—â–∏. –í—ã—Ö–æ–¥–∏—Ç–µ –∏ –ø—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –ø—Ä–æ—Ç–∏–≤ —ç—Ç–æ–π –±–µ—Å–ø–æ–ª–µ–∑–Ω–æ–π –≤–æ–π–Ω—ã. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫—Ä–æ–≤–æ–ø—Ä–æ–ª–∏—Ç–∏–µ. –°–∫–∞–∂–∏—Ç–µ \"–ù–µ—Ç –≤–æ–π–Ω–µ!\"","title":"üá∑üá∫ –†—É—Å—Å–∫–∏–º –≥—Ä–∞–∂–¥–∞–Ω–∞–º"},{"location":"#to-citizens-of-russia","text":"We at Laminas come from all over the world. Many of us have friends, family and colleagues in both Russia and Ukraine. Some of us were born in Russia. Some of us currently live in Russia. Some have grandparents who fought Nazis in World War II. Nobody here supports fascism. One team member has a Ukrainian relative who fled her home with her son. The train was delayed due to bombing on the road ahead. We have friends who are hiding in bomb shelters. We anxiously follow up on them after the air raids, which indiscriminately fire at hospitals, schools, kindergartens and houses. We're not taking this from any media. These are our actual experiences. You trust us enough to use our software. We ask that you trust us to say the truth on this. We need your help. Go out and protest this unnecessary war. Stop the bloodshed. Say \"stop the war!\" Laminas\\Mail provides generalized functionality to compose and send both text and MIME-compliant multipart email messages. Mail can be sent with Laminas\\Mail via the Mail\\Transport\\Sendmail , Mail\\Transport\\Smtp or the Mail\\Transport\\File transport. Of course, you can also implement your own transport by implementing the Mail\\Transport\\TransportInterface . File issues at https://github.com/laminas/laminas-mail/issues Documentation is at https://docs.laminas.dev/laminas-mail/","title":"üá∫üá∏ To Citizens of Russia"},{"location":"intro/","text":"Introduction laminas-mail provides generalized functionality to compose and send both text and MIME-compliant multipart email messages. Mail can be sent with laminas-mail via any of the Sendmail, SMTP, or file-based transports it defines. You can also implement your own transport by implementing the Laminas\\Mail\\Transport\\TransportInterface . Basic email A basic email consists of one or more recipients, a subject, a body and a sender. To send such a mail using Laminas\\Mail\\Transport\\Sendmail , do the following: use Laminas\\Mail; $mail = new Mail\\Message(); $mail-&gt;setBody('This is the text of the email.'); $mail-&gt;setFrom('Freeaqingme@example.org', \"Sender's name\"); $mail-&gt;addTo('Matthew@example.com', 'Name of recipient'); $mail-&gt;setSubject('TestSubject'); $transport = new Mail\\Transport\\Sendmail(); $transport-&gt;send($mail); Minimum definitions In order to send an email using laminas-mail you have to specify at least one recipient as well as a message body. Please note that each transport may require additional parameters to be set. For most mail attributes there are \"get\" methods to read the information stored in the message object. for further details, please refer to the API documentation. Configuring the default sendmail transport The default transport is Laminas\\Mail\\Transport\\Sendmail . It is a wrapper to the PHP mail() function. If you wish to pass additional parameters to the mail() function, create a new transport instance and pass your parameters to the constructor. Passing additional mail() parameters This example shows how to change the Return-Path of the mail() function. use Laminas\\Mail; $mail = new Mail\\Message(); $mail-&gt;setBody('This is the text of the email.'); $mail-&gt;setFrom('Freeaqingme@example.org', 'Dolf'); $mail-&gt;addTo('matthew@example.com', 'Matthew'); $mail-&gt;setSubject('TestSubject'); $transport = new Mail\\Transport\\Sendmail('-freturn_to_me@example.com'); $transport-&gt;send($mail); Chose your transport wisely Although the sendmail transport is the transport that requires least configuration, it may not be suitable for your production environment. This is because emails sent using the sendmail transport will be more often delivered to SPAM-boxes. This can partly be remedied by using the SMTP Transport combined with an SMTP server that has an overall good reputation. Additionally, techniques such as SPF and DKIM may be employed to ensure even more email messages are delivered successfully. Warning: Sendmail Transport and Windows As the PHP manual states, the mail() function has different behaviour on Windows than it does on *nix based systems. Using the sendmail transport on Windows will not work in combination with addBcc() . The mail() function will send to the BCC recipient such that all the other recipients can see that address as the recipient! Therefore if you want to use BCC on a windows server, use the SMTP transport for sending!","title":"Introduction"},{"location":"intro/#introduction","text":"laminas-mail provides generalized functionality to compose and send both text and MIME-compliant multipart email messages. Mail can be sent with laminas-mail via any of the Sendmail, SMTP, or file-based transports it defines. You can also implement your own transport by implementing the Laminas\\Mail\\Transport\\TransportInterface .","title":"Introduction"},{"location":"intro/#basic-email","text":"A basic email consists of one or more recipients, a subject, a body and a sender. To send such a mail using Laminas\\Mail\\Transport\\Sendmail , do the following: use Laminas\\Mail; $mail = new Mail\\Message(); $mail-&gt;setBody('This is the text of the email.'); $mail-&gt;setFrom('Freeaqingme@example.org', \"Sender's name\"); $mail-&gt;addTo('Matthew@example.com', 'Name of recipient'); $mail-&gt;setSubject('TestSubject'); $transport = new Mail\\Transport\\Sendmail(); $transport-&gt;send($mail);","title":"Basic email"},{"location":"intro/#configuring-the-default-sendmail-transport","text":"The default transport is Laminas\\Mail\\Transport\\Sendmail . It is a wrapper to the PHP mail() function. If you wish to pass additional parameters to the mail() function, create a new transport instance and pass your parameters to the constructor.","title":"Configuring the default sendmail transport"},{"location":"read/","text":"Reading and Storing Mail laminas-mail can read mail messages from several local or remote mail storage types. Storage adapters share the same API for counting and fetching messages, and some of them implement additional interfaces for less common features. For a feature overview of the implemented storages, see the following table. Feature Mbox Maildir Pop3 IMAP Storage type local local remote remote Fetch message Yes Yes Yes Yes Fetch MIME-part emulated emulated emulated emulated Folders Yes Yes No Yes Create message/folder No todo No todo Flags No Yes No Yes Quota No Yes No No Storage adapters return instances of Laminas\\Mail\\Storage\\Message , which has a different API than messages used when sending ; the API is described in the \"Working with messages\" section. Basic POP3 example use Laminas\\Mail\\Storage\\Pop3; $mail = new Pop3([ 'host' =&gt; 'localhost', 'user' =&gt; 'test', 'password' =&gt; 'test', ]); echo $mail-&gt;countMessages() . \" messages found\\n\"; foreach ($mail as $message) { printf(\"Mail from '%s': %s\\n\", $message-&gt;from, $message-&gt;subject); } Using local storage via mbox and maildir Mbox and Maildir are the two supported formats for local mail storage. If you want to read from an mbox file, provide the filename to the constructor of Laminas\\Mail\\Storage\\Mbox : use Laminas\\Mail\\Storage\\Mbox; $mail = new Mbox(['filename' =&gt; '/home/test/mail/inbox']); Maildir operates similarly, but requires a dirname instead: use Laminas\\Mail\\Storage\\Maildir; $mail = new Maildir(['dirname' =&gt; '/home/test/mail/']); Both constructors throw a Laminas\\Mail\\Exception if the storage can't be read. Using remote storage protocols For remote storage, the two most popular protocols are supported: POP3 and IMAP. Both need at least a host and a user to connect and login. The default password is an empty string, and the default port for the protocol is used if none is provided. use Laminas\\Mail\\Storage\\Imap; use Laminas\\Mail\\Storage\\Pop3; // Connecting with Pop3: $mail = new Pop3([ 'host' =&gt; 'example.com', 'user' =&gt; 'test', 'password' =&gt; 'test', ]); // Connecting with Imap: $mail = new Imap([ 'host' =&gt; 'example.com', 'user' =&gt; 'test', 'password' =&gt; 'test', ]); // Example of using POP3 on a non-standard port: $mail = new Pop3([ 'host' =&gt; 'example.com', 'port' =&gt; 1120, 'user' =&gt; 'test', 'password' =&gt; 'test', ]); Both storage adapters support SSL and TLS. If you use SSL, the default port changes as specified in the relevant RFC. use Laminas\\Mail\\Storage\\Pop3; // Examples use Pop3; the same configuration works for Imap. // Use SSL on a non-standard port (default is 995 for Pop3 and 993 for Imap) $mail = new Pop3([ 'host' =&gt; 'example.com', 'user' =&gt; 'test', 'password' =&gt; 'test', 'ssl' =&gt; 'SSL', ]); // use TLS on the default port: $mail = new Pop3([ 'host' =&gt; 'example.com', 'user' =&gt; 'test', 'password' =&gt; 'test', 'ssl' =&gt; 'TLS', ]); If you are connecting to a mail server with a self-signed certificate and want to skip the SSL verification, you can also pass an additional argument novalidatecert with the value true . Both constructors throw Laminas\\Mail\\Exception or Laminas\\Mail\\Protocol\\Exception (extends Laminas\\Mail\\Exception ) for connection errors, depending on the type of error encountered. Fetching, counting, and removing messages Once you have opened the mail storage, you may fetch messages. To do so, you need the message number, which is a counter starting with 1 for the first message. To fetch the message, you use the method getMessage() : $message = $mail-&gt;getMessage($messageNum); Array access is also supported, but this access method does not support any additional parameters that could be added to getMessage() . As long as you don't mind, and can live with the default values, you may use: $message = $mail[$messageNum]; For iterating over all messages the Iterator interface is implemented: foreach ($mail as $messageNum =&gt; $message) { // do stuff ... } To count the messages in the storage, you can use the method countMessages() ; alternately, storage adapters implement Countable , allowing you to count() the instance. // method $maxMessage = $mail-&gt;countMessages(); // array access $maxMessage = count($mail); To remove a mail, use the method removeMessage() , or rely on array access and use unset() : // method $mail-&gt;removeMessage($messageNum); // array access unset($mail[$messageNum]); Working with messages After you fetch a message, you can: fetch headers fetch the message content fetch individual parts of multipart messages All headers can be accessed as message instance properties or via the method getHeader() ; use the latter for messages with compound names. Header names are normalized to lowercase internally, but may be fetched using any case structure; dash-separated headers may be fetched using camelCase notation. If no header matching the name is found, an exception is thrown; use the headerExists() method (or isset($message-&gt;headerName) ) to test for header existence prior to retrieval. // get the message object $message = $mail-&gt;getMessage(1); // output subject of message echo $message-&gt;subject . \"\\n\"; // get content-type header $type = $message-&gt;contentType; // check if CC isset: if (isset($message-&gt;cc)) { // or $message-&gt;headerExists('cc'); $cc = $message-&gt;cc; } If you have multiple headers with the same name ‚Äî e.g. the Received headers ‚Äî you will want an array of values. Property access always returns a string, so use getHeader() instead for these situations: // get header as property - the result is always a string, // with new lines between each value. $received = $message-&gt;received; // The same via getHeader() method: $received = $message-&gt;getHeader('received', 'string'); // To retrieve an array of values: $received = $message-&gt;getHeader('received', 'array'); foreach ($received as $line) { // do stuff } // If you don't define a format you'll get the internal representation // (string for single headers, array for multiple): $received = $message-&gt;getHeader('received'); if (is_string($received)) { // only one received header found in message } The method getHeaders() returns all headers as an array with the lower-cased name as the key and the value as an array for multiple headers or as string for single headers. // dump all headers foreach ($message-&gt;getHeaders() as $name =&gt; $value) { if (is_string($value)) { echo \"$name: $value\\n\"; continue; } foreach ($value as $entry) { echo \"$name: $entry\\n\"; } } If you don't have a multipart message, fetch the content via getContent() . Unlike headers, the content is only fetched when needed (aka late-fetch). // output message content for HTML echo '&lt;pre&gt;'; echo $message-&gt;getContent(); echo '&lt;/pre&gt;'; Checking for multipart messages is done with the method isMultipart() . If you have a multipart message you, can get retrieve the individual Laminas\\Mail\\Storage\\Part instances making up the message via the getPart() method, which accepts the part index as a parameter (indices start with 1). Laminas\\Mail\\Storage\\Part is the base class of Laminas\\Mail\\Storage\\Message , and thus exposes the same API with regards to headers, content, and retrieving nested parts. // get the first non-multipart part $part = $message; while ($part-&gt;isMultipart()) { $part = $message-&gt;getPart(1); } echo 'Type of this part is ' . strtok($part-&gt;contentType, ';') . \"\\n\"; echo \"Content:\\n\"; echo $part-&gt;getContent(); Laminas\\Mail\\Storage\\Part also implements RecursiveIterator , which allows iterating through all parts, even when nested. Additionally, it implements the magic method __toString() , which returns the content. use RecursiveIteratorIterator; use Laminas\\Mail\\Exception; // output first text/plain part $foundPart = null; foreach (new RecursiveIteratorIterator($mail-&gt;getMessage(1)) as $part) { try { if (strtok($part-&gt;contentType, ';') == 'text/plain') { $foundPart = $part; break; } } catch (Exception $e) { // ignore } } if (! $foundPart) { echo 'no plain text part found'; } else { echo \"plain text part: \\n\" . $foundPart; } Checking for flags Maildir and IMAP support storing flags with messages. The Laminas\\Mail\\Storage class defines constants for all known maildir and IMAP system flags, named FLAG_&lt;flagname&gt; . To check for flags, Laminas\\Mail\\Storage\\Message has a method called hasFlag() . With getFlags() you'll get all flags. use Laminas\\Mail\\Storage; // Find unread messages: echo \"Unread mails:\\n\"; foreach ($mail as $message) { if ($message-&gt;hasFlag(Storage::FLAG_SEEN)) { continue; } // mark recent/new mails echo ($message-&gt;hasFlag(Storage::FLAG_RECENT)) ? '! ' : ' '; echo $message-&gt;subject . \"\\n\"; } // Check for known flags $flags = $message-&gt;getFlags(); echo 'Message is flagged as: '; foreach ($flags as $flag) { switch ($flag) { case Storage::FLAG_ANSWERED: echo 'Answered '; break; case Storage::FLAG_FLAGGED: echo 'Flagged '; break; // ... // check for other flags // ... default: echo $flag . '(unknown flag) '; } } As IMAP allows user or client defined flags, you could get flags that don't have a constant in Laminas\\Mail\\Storage . Instead, they are returned as strings and can be checked the same way with hasFlag() . // check message for client defined flags $IsSpam, $SpamTested if (! $message-&gt;hasFlag('$SpamTested')) { echo 'message has not been tested for spam'; } elseif ($message-&gt;hasFlag('$IsSpam')) { echo 'this message is spam'; } else { echo 'this message is ham'; } Using folders All storage adapters except POP3 support folders (also called mailboxes ). The interface implemented by all adapters supporting folders is called Laminas\\Mail\\Storage\\Folder\\FolderInterface . Each also supports an optional configuration parameter called folder , which is the folder selected after login. For the local storage adapters, you need to use the adapter-specific folder classes, Laminas\\Mail\\Storage\\Folder\\Mbox and Laminas\\Mail\\Storage\\Folder\\Maildir . Each accepts a single parameter, dirname , with the name of the base direcor. The format for maildir is as defined in maildir++ (with a dot as default delimiter); mbox uses a directory hierarchy of mbox files. If you don't have an mbox file called INBOX in your mbox base directory, you need to specify another folder via the constructor. Laminas\\Mail\\Storage\\Imap supports folders by default. Examples for opening folders with each adapter: use Laminas\\Mail\\Storage\\Folder; use Laminas\\Mail\\Storage\\Imap; // mbox with folders: $mail = new Folder\\Mbox(['dirname' =&gt; '/home/test/mail/']); // mbox with a default folder not called INBOX; also works // with the maildir and IMAP implementations. $mail = new Folder\\Mbox([ 'dirname' =&gt; '/home/test/mail/', 'folder' =&gt; 'Archive', ]); // maildir with folders: $mail = new Folder\\Maildir(['dirname' =&gt; '/home/test/mail/']); // maildir with colon as delimiter, as suggested in Maildir++: $mail = new Folder\\Maildir([ 'dirname' =&gt; '/home/test/mail/', 'delim' =&gt; ':', ]); // IMAP is the same with and without folders: $mail = new Imap([ 'host' =&gt; 'example.com', 'user' =&gt; 'test', 'password' =&gt; 'test', ]); With the method getFolders($root = null) , you can get the folder hierarchy starting with the root folder, or the given folder. The method returns an instance of Laminas\\Mail\\Storage\\Folder , which implements RecursiveIterator , and all children are also instances of Folder . Each of these instances has a local and a global name returned by the methods getLocalName() and getGlobalName() . The global name is the absolute name from the root folder (including delimiters); the local name is the name in the parent folder. If you use the iterator, the key of the current element is the local name. The global name is also returned by the magic method __toString() . Some folders may not be selectable, which means they can't store messages; selecting them results in an error. This can be checked with the method isSelectable() . The following demonstrates providing a tree view of a folder: use RecursiveIteratorIterator; $folders = new RecursiveIteratorIterator( $this-&gt;mail-&gt;getFolders(), RecursiveIteratorIterator::SELF_FIRST ); echo '&lt;select name=\"folder\"&gt;'; foreach ($folders as $localName =&gt; $folder) { $localName = str_pad('', $folders-&gt;getDepth(), '-', STR_PAD_LEFT) . $localName; echo '&lt;option'; if (! $folder-&gt;isSelectable()) { echo ' disabled=\"disabled\"'; } printf( ' value=\"%s\"&gt;%s&lt;/option&gt;', htmlspecialchars($folder), htmlspecialchars($localName) ); } echo '&lt;/select&gt;'; The current selected folder is returned by the method getSelectedFolder() . Changing the folder is done with the method selectFolder() , which needs the global name as a parameter. If you want to avoid writing delimiters, you can also use the properties of a Folder instance: // depending on your mail storage and its settings $rootFolder-&gt;Archive-&gt;2005 // is the same as: // /Archive/2005 // Archive:2005 // INBOX.Archive.2005 // ... $folder = $mail-&gt;getFolders()-&gt;Archive-&gt;2005; printf(\"Last folder was %s; new folder is %s\\n\", $mail-&gt;getSelectedFolder(), $folder); $mail-&gt;selectFolder($folder); Advanced Use Using NOOP If you're using a remote storage and have some long tasks, you might need to keep the connection alive via noop: foreach ($mail as $message) { // do some calculations ... $mail-&gt;noop(); // keep alive // do something else ... $mail-&gt;noop(); // keep alive } Caching instances Laminas\\Mail\\Storage\\Mbox , Laminas\\Mail\\Storage\\Folder\\Mbox , Laminas\\Mail\\Storage\\Maildir , and Laminas\\Mail\\Storage\\Folder\\Maildir implement the magic methods __sleep() and __wakeup() , which means they are serializable. Serialization avoids parsing files and directory trees multiple times. The disadvantage is that your mbox or maildir storage should not change; as such, its best used with static storage. You can combine serialization with writable storage in a number of ways: Check the current mbox file for modification time changes. Reparse the folder structure if a folder has vanished (which still results in an error, but you can search for another folder afterwards). Create a signal file whenever a change is made; check for that signal file, reparse if present, and remove it afterwards. use Laminas\\Mail\\Storage\\Folder\\Mbox; // There's no specific cache handler/class used here, // change the code to match your cache handler. $signalFile = '/home/test/.mail.last_change'; $mboxBasedir = '/home/test/mail/'; $cacheId = 'example mail cache ' . $mboxBasedir . $signalFile; $cache = new Cache(); $hasCache = ($cache-&gt;has($cacheId) &amp;&amp; filemtime($signalFile) &lt;= $cache-&gt;getMTime($cacheId) ); $mail = $hasCache ? $cache-&gt;get($cacheId) : new Mbox(['dirname' =&gt; $mboxBasedir]); // do stuff ... // Cache when done $cache-&gt;set($cacheId, $mail); Extending Protocol Classes Remote storage adapters use two classes: Laminas\\Mail\\Storage\\&lt;Name&gt; and Laminas\\Mail\\Protocol\\&lt;Name&gt; . The protocol class translates the protocol commands and responses from and to PHP, like methods for the commands or variables with different structures for data. The storage class implements the common interface for message access. If you need additional protocol features, you can extend the protocol class and use it in the constructor of the main class. As an example, assume we need to knock different ports before we can connect to POP3. namespace Example\\Mail { use Laminas\\Mail; class Exception extends Mail\\Exception { } } namespace Example\\Mail\\Protocol { use Laminas\\Mail\\Protocol; class Exception extends Protocol\\Exception { } } namespace Example\\Mail\\Protocol\\Pop3 { use Laminas\\Mail\\Protocol\\Pop3; class Knock extends Pop3 { private $host private $port; public function __construct($host, $port = null) { // no auto connect in this class $this-&gt;host = $host; $this-&gt;port = $port; } public function knock($port) { $sock = @fsockopen($this-&gt;host, $port); if ($sock) { fclose($sock); } } public function connect($host = null, $port = null, $ssl = false) { if ($host === null) { $host = $this-&gt;host; } if ($port === null) { $port = $this-&gt;port; } parent::connect($host, $port); } } } namespace Example\\Mail\\Pop3 { use Example\\Mail\\Protoco\\Pop3\\Knock as KnockProtocol; use Laminas\\Mail\\Storage\\Pop3; class Knock extends Pop3 { public function __construct(array $params) { // ... check $params here! ... $protocol = new KnockProtocol($params['host']); // do our \"special\" thing foreach ((array) $params['knock_ports'] as $port) { $protocol-&gt;knock($port); } // get to correct state $protocol-&gt;connect($params['host'], $params['port']); $protocol-&gt;login($params['user'], $params['password']); // initialize parent parent::__construct($protocol); } } } $mail = new Example\\Mail\\Pop3\\Knock([ 'host' =&gt; 'localhost', 'user' =&gt; 'test', 'password' =&gt; 'test', 'knock_ports' =&gt; [1101, 1105, 1111], ]); The above assumes a connection is made; when connected, it logs in and, if supported, selects a folder as provided to the constructor. When defining your own protocol class, make sure that's done or the next method will fail if the server doesn't allow it in the current state. Using Quotas Laminas\\Mail\\Storage\\Writable\\Maildir has support for Maildir++ quotas. It's disabled by default, but it's possible to use it manually, if the automatic checks are not desired (this means appendMessage() , removeMessage() , and copyMessage() do no checks and do not add entries to the maildirsize file). If enabled, an exception is thrown if you try to write to the maildir and it's already over quota. There are three methods used for quotas: getQuota() , setQuota() , and checkQuota() : use Laminas\\Mail\\Storage\\Writable\\Maildir; $mail = new Maildir(['dirname' =&gt; '/home/test/mail/']); $mail-&gt;setQuota(true); // true to enable, false to disable printf(\"Quota check is now %s\\n\", $mail-&gt;getQuota() ? 'enabled' : 'disabled'); // Check quota can be used even if quota checks are disabled: printf(\"You are %sover quota\\n\", $mail-&gt;checkQuota() ? '' : 'not '); checkQuota() can also return a more detailed response by passing a boolean true argument: $quota = $mail-&gt;checkQuota(true); printf(\"You are %sover quota\\n\", $quota['over_quota'] ? '' : 'not '); printf( \"You have %d of %d messages and use %d of %d octets\\n\", $quota['count'], $quota['quota']['count'], $quota['size'], $quota['quota']['size'] ); If you want to specify your own quota instead of using the one specified in the maildirsize file, you can do with setQuota() : // Message count and octet size supported; order does matter. $quota = $mail-&gt;setQuota(['size' =&gt; 10000, 'count' =&gt; 100]); To add your own quota checks, use single letters as keys, and they will be preserved (but obviously not checked). It's also possible to extend Laminas\\Mail\\Storage\\Writable\\Maildir to define your own quota if the maildirsize file is missing (which can happen in Maildir++): namespace Example\\Mail\\Storage; use Laminas\\Mail\\Storage\\Exception; use Laminas\\Mail\\Storage\\Writable\\Maildir as BaseMaildir; class Maildir extends BaseMaildir { /** * getQuota is called with $fromStorage = true by quota checks. * * @param bool $fromStorage * @return bool|array */ public function getQuota($fromStorage = false) { try { return parent::getQuota($fromStorage); } catch (Exception $e) { if (! $fromStorage) { // unknown error: throw $e; } // maildirsize file must be missing list($count, $size) = get_quota_from_somewhere_else(); return ['count' =&gt; $count, 'size' =&gt; $size]; } } }","title":"Reading and Storing Mail"},{"location":"read/#reading-and-storing-mail","text":"laminas-mail can read mail messages from several local or remote mail storage types. Storage adapters share the same API for counting and fetching messages, and some of them implement additional interfaces for less common features. For a feature overview of the implemented storages, see the following table. Feature Mbox Maildir Pop3 IMAP Storage type local local remote remote Fetch message Yes Yes Yes Yes Fetch MIME-part emulated emulated emulated emulated Folders Yes Yes No Yes Create message/folder No todo No todo Flags No Yes No Yes Quota No Yes No No Storage adapters return instances of Laminas\\Mail\\Storage\\Message , which has a different API than messages used when sending ; the API is described in the \"Working with messages\" section.","title":"Reading and Storing Mail"},{"location":"read/#basic-pop3-example","text":"use Laminas\\Mail\\Storage\\Pop3; $mail = new Pop3([ 'host' =&gt; 'localhost', 'user' =&gt; 'test', 'password' =&gt; 'test', ]); echo $mail-&gt;countMessages() . \" messages found\\n\"; foreach ($mail as $message) { printf(\"Mail from '%s': %s\\n\", $message-&gt;from, $message-&gt;subject); }","title":"Basic POP3 example"},{"location":"read/#using-local-storage-via-mbox-and-maildir","text":"Mbox and Maildir are the two supported formats for local mail storage. If you want to read from an mbox file, provide the filename to the constructor of Laminas\\Mail\\Storage\\Mbox : use Laminas\\Mail\\Storage\\Mbox; $mail = new Mbox(['filename' =&gt; '/home/test/mail/inbox']); Maildir operates similarly, but requires a dirname instead: use Laminas\\Mail\\Storage\\Maildir; $mail = new Maildir(['dirname' =&gt; '/home/test/mail/']); Both constructors throw a Laminas\\Mail\\Exception if the storage can't be read.","title":"Using local storage via mbox and maildir"},{"location":"read/#using-remote-storage-protocols","text":"For remote storage, the two most popular protocols are supported: POP3 and IMAP. Both need at least a host and a user to connect and login. The default password is an empty string, and the default port for the protocol is used if none is provided. use Laminas\\Mail\\Storage\\Imap; use Laminas\\Mail\\Storage\\Pop3; // Connecting with Pop3: $mail = new Pop3([ 'host' =&gt; 'example.com', 'user' =&gt; 'test', 'password' =&gt; 'test', ]); // Connecting with Imap: $mail = new Imap([ 'host' =&gt; 'example.com', 'user' =&gt; 'test', 'password' =&gt; 'test', ]); // Example of using POP3 on a non-standard port: $mail = new Pop3([ 'host' =&gt; 'example.com', 'port' =&gt; 1120, 'user' =&gt; 'test', 'password' =&gt; 'test', ]); Both storage adapters support SSL and TLS. If you use SSL, the default port changes as specified in the relevant RFC. use Laminas\\Mail\\Storage\\Pop3; // Examples use Pop3; the same configuration works for Imap. // Use SSL on a non-standard port (default is 995 for Pop3 and 993 for Imap) $mail = new Pop3([ 'host' =&gt; 'example.com', 'user' =&gt; 'test', 'password' =&gt; 'test', 'ssl' =&gt; 'SSL', ]); // use TLS on the default port: $mail = new Pop3([ 'host' =&gt; 'example.com', 'user' =&gt; 'test', 'password' =&gt; 'test', 'ssl' =&gt; 'TLS', ]); If you are connecting to a mail server with a self-signed certificate and want to skip the SSL verification, you can also pass an additional argument novalidatecert with the value true . Both constructors throw Laminas\\Mail\\Exception or Laminas\\Mail\\Protocol\\Exception (extends Laminas\\Mail\\Exception ) for connection errors, depending on the type of error encountered.","title":"Using remote storage protocols"},{"location":"read/#fetching-counting-and-removing-messages","text":"Once you have opened the mail storage, you may fetch messages. To do so, you need the message number, which is a counter starting with 1 for the first message. To fetch the message, you use the method getMessage() : $message = $mail-&gt;getMessage($messageNum); Array access is also supported, but this access method does not support any additional parameters that could be added to getMessage() . As long as you don't mind, and can live with the default values, you may use: $message = $mail[$messageNum]; For iterating over all messages the Iterator interface is implemented: foreach ($mail as $messageNum =&gt; $message) { // do stuff ... } To count the messages in the storage, you can use the method countMessages() ; alternately, storage adapters implement Countable , allowing you to count() the instance. // method $maxMessage = $mail-&gt;countMessages(); // array access $maxMessage = count($mail); To remove a mail, use the method removeMessage() , or rely on array access and use unset() : // method $mail-&gt;removeMessage($messageNum); // array access unset($mail[$messageNum]);","title":"Fetching, counting, and removing messages"},{"location":"read/#working-with-messages","text":"After you fetch a message, you can: fetch headers fetch the message content fetch individual parts of multipart messages All headers can be accessed as message instance properties or via the method getHeader() ; use the latter for messages with compound names. Header names are normalized to lowercase internally, but may be fetched using any case structure; dash-separated headers may be fetched using camelCase notation. If no header matching the name is found, an exception is thrown; use the headerExists() method (or isset($message-&gt;headerName) ) to test for header existence prior to retrieval. // get the message object $message = $mail-&gt;getMessage(1); // output subject of message echo $message-&gt;subject . \"\\n\"; // get content-type header $type = $message-&gt;contentType; // check if CC isset: if (isset($message-&gt;cc)) { // or $message-&gt;headerExists('cc'); $cc = $message-&gt;cc; } If you have multiple headers with the same name ‚Äî e.g. the Received headers ‚Äî you will want an array of values. Property access always returns a string, so use getHeader() instead for these situations: // get header as property - the result is always a string, // with new lines between each value. $received = $message-&gt;received; // The same via getHeader() method: $received = $message-&gt;getHeader('received', 'string'); // To retrieve an array of values: $received = $message-&gt;getHeader('received', 'array'); foreach ($received as $line) { // do stuff } // If you don't define a format you'll get the internal representation // (string for single headers, array for multiple): $received = $message-&gt;getHeader('received'); if (is_string($received)) { // only one received header found in message } The method getHeaders() returns all headers as an array with the lower-cased name as the key and the value as an array for multiple headers or as string for single headers. // dump all headers foreach ($message-&gt;getHeaders() as $name =&gt; $value) { if (is_string($value)) { echo \"$name: $value\\n\"; continue; } foreach ($value as $entry) { echo \"$name: $entry\\n\"; } } If you don't have a multipart message, fetch the content via getContent() . Unlike headers, the content is only fetched when needed (aka late-fetch). // output message content for HTML echo '&lt;pre&gt;'; echo $message-&gt;getContent(); echo '&lt;/pre&gt;'; Checking for multipart messages is done with the method isMultipart() . If you have a multipart message you, can get retrieve the individual Laminas\\Mail\\Storage\\Part instances making up the message via the getPart() method, which accepts the part index as a parameter (indices start with 1). Laminas\\Mail\\Storage\\Part is the base class of Laminas\\Mail\\Storage\\Message , and thus exposes the same API with regards to headers, content, and retrieving nested parts. // get the first non-multipart part $part = $message; while ($part-&gt;isMultipart()) { $part = $message-&gt;getPart(1); } echo 'Type of this part is ' . strtok($part-&gt;contentType, ';') . \"\\n\"; echo \"Content:\\n\"; echo $part-&gt;getContent(); Laminas\\Mail\\Storage\\Part also implements RecursiveIterator , which allows iterating through all parts, even when nested. Additionally, it implements the magic method __toString() , which returns the content. use RecursiveIteratorIterator; use Laminas\\Mail\\Exception; // output first text/plain part $foundPart = null; foreach (new RecursiveIteratorIterator($mail-&gt;getMessage(1)) as $part) { try { if (strtok($part-&gt;contentType, ';') == 'text/plain') { $foundPart = $part; break; } } catch (Exception $e) { // ignore } } if (! $foundPart) { echo 'no plain text part found'; } else { echo \"plain text part: \\n\" . $foundPart; }","title":"Working with messages"},{"location":"read/#checking-for-flags","text":"Maildir and IMAP support storing flags with messages. The Laminas\\Mail\\Storage class defines constants for all known maildir and IMAP system flags, named FLAG_&lt;flagname&gt; . To check for flags, Laminas\\Mail\\Storage\\Message has a method called hasFlag() . With getFlags() you'll get all flags. use Laminas\\Mail\\Storage; // Find unread messages: echo \"Unread mails:\\n\"; foreach ($mail as $message) { if ($message-&gt;hasFlag(Storage::FLAG_SEEN)) { continue; } // mark recent/new mails echo ($message-&gt;hasFlag(Storage::FLAG_RECENT)) ? '! ' : ' '; echo $message-&gt;subject . \"\\n\"; } // Check for known flags $flags = $message-&gt;getFlags(); echo 'Message is flagged as: '; foreach ($flags as $flag) { switch ($flag) { case Storage::FLAG_ANSWERED: echo 'Answered '; break; case Storage::FLAG_FLAGGED: echo 'Flagged '; break; // ... // check for other flags // ... default: echo $flag . '(unknown flag) '; } } As IMAP allows user or client defined flags, you could get flags that don't have a constant in Laminas\\Mail\\Storage . Instead, they are returned as strings and can be checked the same way with hasFlag() . // check message for client defined flags $IsSpam, $SpamTested if (! $message-&gt;hasFlag('$SpamTested')) { echo 'message has not been tested for spam'; } elseif ($message-&gt;hasFlag('$IsSpam')) { echo 'this message is spam'; } else { echo 'this message is ham'; }","title":"Checking for flags"},{"location":"read/#using-folders","text":"All storage adapters except POP3 support folders (also called mailboxes ). The interface implemented by all adapters supporting folders is called Laminas\\Mail\\Storage\\Folder\\FolderInterface . Each also supports an optional configuration parameter called folder , which is the folder selected after login. For the local storage adapters, you need to use the adapter-specific folder classes, Laminas\\Mail\\Storage\\Folder\\Mbox and Laminas\\Mail\\Storage\\Folder\\Maildir . Each accepts a single parameter, dirname , with the name of the base direcor. The format for maildir is as defined in maildir++ (with a dot as default delimiter); mbox uses a directory hierarchy of mbox files. If you don't have an mbox file called INBOX in your mbox base directory, you need to specify another folder via the constructor. Laminas\\Mail\\Storage\\Imap supports folders by default. Examples for opening folders with each adapter: use Laminas\\Mail\\Storage\\Folder; use Laminas\\Mail\\Storage\\Imap; // mbox with folders: $mail = new Folder\\Mbox(['dirname' =&gt; '/home/test/mail/']); // mbox with a default folder not called INBOX; also works // with the maildir and IMAP implementations. $mail = new Folder\\Mbox([ 'dirname' =&gt; '/home/test/mail/', 'folder' =&gt; 'Archive', ]); // maildir with folders: $mail = new Folder\\Maildir(['dirname' =&gt; '/home/test/mail/']); // maildir with colon as delimiter, as suggested in Maildir++: $mail = new Folder\\Maildir([ 'dirname' =&gt; '/home/test/mail/', 'delim' =&gt; ':', ]); // IMAP is the same with and without folders: $mail = new Imap([ 'host' =&gt; 'example.com', 'user' =&gt; 'test', 'password' =&gt; 'test', ]); With the method getFolders($root = null) , you can get the folder hierarchy starting with the root folder, or the given folder. The method returns an instance of Laminas\\Mail\\Storage\\Folder , which implements RecursiveIterator , and all children are also instances of Folder . Each of these instances has a local and a global name returned by the methods getLocalName() and getGlobalName() . The global name is the absolute name from the root folder (including delimiters); the local name is the name in the parent folder. If you use the iterator, the key of the current element is the local name. The global name is also returned by the magic method __toString() . Some folders may not be selectable, which means they can't store messages; selecting them results in an error. This can be checked with the method isSelectable() . The following demonstrates providing a tree view of a folder: use RecursiveIteratorIterator; $folders = new RecursiveIteratorIterator( $this-&gt;mail-&gt;getFolders(), RecursiveIteratorIterator::SELF_FIRST ); echo '&lt;select name=\"folder\"&gt;'; foreach ($folders as $localName =&gt; $folder) { $localName = str_pad('', $folders-&gt;getDepth(), '-', STR_PAD_LEFT) . $localName; echo '&lt;option'; if (! $folder-&gt;isSelectable()) { echo ' disabled=\"disabled\"'; } printf( ' value=\"%s\"&gt;%s&lt;/option&gt;', htmlspecialchars($folder), htmlspecialchars($localName) ); } echo '&lt;/select&gt;'; The current selected folder is returned by the method getSelectedFolder() . Changing the folder is done with the method selectFolder() , which needs the global name as a parameter. If you want to avoid writing delimiters, you can also use the properties of a Folder instance: // depending on your mail storage and its settings $rootFolder-&gt;Archive-&gt;2005 // is the same as: // /Archive/2005 // Archive:2005 // INBOX.Archive.2005 // ... $folder = $mail-&gt;getFolders()-&gt;Archive-&gt;2005; printf(\"Last folder was %s; new folder is %s\\n\", $mail-&gt;getSelectedFolder(), $folder); $mail-&gt;selectFolder($folder);","title":"Using folders"},{"location":"read/#advanced-use","text":"","title":"Advanced Use"},{"location":"message/attachments/","text":"Adding Attachments laminas-mail does not directly provide the ability to create and use mail attachments. However, it allows using Laminas\\Mime\\Message instances, from the laminas-mime component, for message bodies, allowing you to create multipart emails. Basic multipart content The following example creates an email with two parts, HTML content and an image. use Laminas\\Mail\\Message; use Laminas\\Mime\\Message as MimeMessage; use Laminas\\Mime\\Mime; use Laminas\\Mime\\Part as MimePart; $html = new MimePart($htmlMarkup); $html-&gt;type = Mime::TYPE_HTML; $html-&gt;charset = 'utf-8'; $html-&gt;encoding = Mime::ENCODING_QUOTEDPRINTABLE; $image = new MimePart(fopen($pathToImage, 'r')); $image-&gt;type = 'image/jpeg'; $image-&gt;filename = 'image-file-name.jpg'; $image-&gt;disposition = Mime::DISPOSITION_ATTACHMENT; $image-&gt;encoding = Mime::ENCODING_BASE64; $body = new MimeMessage(); $body-&gt;setParts([$html, $image]); $message = new Message(); $message-&gt;setBody($body); $contentTypeHeader = $message-&gt;getHeaders()-&gt;get('Content-Type'); $contentTypeHeader-&gt;setType('multipart/related'); Note that the above code requires us to manually specify the message content type; laminas-mime does not automatically select the multipart type for us, nor does laminas-mail populate it by default. multipart/alternative content One of the most common email types sent by web applications is multipart/alternative messages with both text and HTML parts. use Laminas\\Mail\\Message; use Laminas\\Mime\\Message as MimeMessage; use Laminas\\Mime\\Mime; use Laminas\\Mime\\Part as MimePart; $text = new MimePart($textContent); $text-&gt;type = Mime::TYPE_TEXT; $text-&gt;charset = 'utf-8'; $text-&gt;encoding = Mime::ENCODING_QUOTEDPRINTABLE; $html = new MimePart($htmlMarkup); $html-&gt;type = Mime::TYPE_HTML; $html-&gt;charset = 'utf-8'; $html-&gt;encoding = Mime::ENCODING_QUOTEDPRINTABLE; $body = new MimeMessage(); $body-&gt;setParts([$text, $html]); $message = new Message(); $message-&gt;setBody($body); $contentTypeHeader = $message-&gt;getHeaders()-&gt;get('Content-Type'); $contentTypeHeader-&gt;setType('multipart/alternative'); The only differences from the first example are: We have text and HTML parts instead of an HTML and image part. The Content-Type header is now multipart/alternative . multipart/alternative emails with attachments Another common task is creating multipart/alternative emails where the HTML content refers to assets attachments (images, CSS, etc.). To accomplish this, we need to: Create a Laminas\\Mime\\Part instance containing our multipart/alternative message. Add that part to a Laminas\\Mime\\Message . Add additional Laminas\\Mime\\Part instances to the MIME message. Attach the MIME message as the Laminas\\Mail\\Message content body. Mark the message as multipart/related content. The following example creates a MIME message with three parts: text and HTML alternative versions of an email, and an image attachment. use Laminas\\Mail\\Message; use Laminas\\Mime\\Message as MimeMessage; use Laminas\\Mime\\Mime; use Laminas\\Mime\\Part as MimePart; $body = new MimeMessage(); $text = new MimePart($textContent); $text-&gt;type = Mime::TYPE_TEXT; $text-&gt;charset = 'utf-8'; $text-&gt;encoding = Mime::ENCODING_QUOTEDPRINTABLE; $html = new MimePart($htmlMarkup); $html-&gt;type = Mime::TYPE_HTML; $html-&gt;charset = 'utf-8'; $html-&gt;encoding = Mime::ENCODING_QUOTEDPRINTABLE; $content = new MimeMessage(); // This order is important for email clients to properly display the correct version of the content $content-&gt;setParts([$text, $html]); $contentPart = new MimePart($content-&gt;generateMessage()); $image = new MimePart(fopen($pathToImage, 'r')); $image-&gt;type = 'image/jpeg'; $image-&gt;filename = 'image-file-name.jpg'; $image-&gt;disposition = Mime::DISPOSITION_ATTACHMENT; $image-&gt;encoding = Mime::ENCODING_BASE64; $body = new MimeMessage(); $body-&gt;setParts([$contentPart, $image]); $message = new Message(); $message-&gt;setBody($body); $contentTypeHeader = $message-&gt;getHeaders()-&gt;get('Content-Type'); $contentTypeHeader-&gt;setType('multipart/related'); Setting custom MIME boundaries In a multipart message, a MIME boundary for separating the different parts of the message is normally generated at random. In some cases, however, you might want to specify the MIME boundary that is used. This can be done by injecting a new Laminas\\Mime\\Mime instance into the MIME message. use Laminas\\Mime\\Mime; $mimeMessage-&gt;setMime(new Mime($customBoundary));","title":"Attachments"},{"location":"message/attachments/#adding-attachments","text":"laminas-mail does not directly provide the ability to create and use mail attachments. However, it allows using Laminas\\Mime\\Message instances, from the laminas-mime component, for message bodies, allowing you to create multipart emails.","title":"Adding Attachments"},{"location":"message/attachments/#basic-multipart-content","text":"The following example creates an email with two parts, HTML content and an image. use Laminas\\Mail\\Message; use Laminas\\Mime\\Message as MimeMessage; use Laminas\\Mime\\Mime; use Laminas\\Mime\\Part as MimePart; $html = new MimePart($htmlMarkup); $html-&gt;type = Mime::TYPE_HTML; $html-&gt;charset = 'utf-8'; $html-&gt;encoding = Mime::ENCODING_QUOTEDPRINTABLE; $image = new MimePart(fopen($pathToImage, 'r')); $image-&gt;type = 'image/jpeg'; $image-&gt;filename = 'image-file-name.jpg'; $image-&gt;disposition = Mime::DISPOSITION_ATTACHMENT; $image-&gt;encoding = Mime::ENCODING_BASE64; $body = new MimeMessage(); $body-&gt;setParts([$html, $image]); $message = new Message(); $message-&gt;setBody($body); $contentTypeHeader = $message-&gt;getHeaders()-&gt;get('Content-Type'); $contentTypeHeader-&gt;setType('multipart/related'); Note that the above code requires us to manually specify the message content type; laminas-mime does not automatically select the multipart type for us, nor does laminas-mail populate it by default.","title":"Basic multipart content"},{"location":"message/attachments/#multipartalternative-content","text":"One of the most common email types sent by web applications is multipart/alternative messages with both text and HTML parts. use Laminas\\Mail\\Message; use Laminas\\Mime\\Message as MimeMessage; use Laminas\\Mime\\Mime; use Laminas\\Mime\\Part as MimePart; $text = new MimePart($textContent); $text-&gt;type = Mime::TYPE_TEXT; $text-&gt;charset = 'utf-8'; $text-&gt;encoding = Mime::ENCODING_QUOTEDPRINTABLE; $html = new MimePart($htmlMarkup); $html-&gt;type = Mime::TYPE_HTML; $html-&gt;charset = 'utf-8'; $html-&gt;encoding = Mime::ENCODING_QUOTEDPRINTABLE; $body = new MimeMessage(); $body-&gt;setParts([$text, $html]); $message = new Message(); $message-&gt;setBody($body); $contentTypeHeader = $message-&gt;getHeaders()-&gt;get('Content-Type'); $contentTypeHeader-&gt;setType('multipart/alternative'); The only differences from the first example are: We have text and HTML parts instead of an HTML and image part. The Content-Type header is now multipart/alternative .","title":"multipart/alternative content"},{"location":"message/attachments/#multipartalternative-emails-with-attachments","text":"Another common task is creating multipart/alternative emails where the HTML content refers to assets attachments (images, CSS, etc.). To accomplish this, we need to: Create a Laminas\\Mime\\Part instance containing our multipart/alternative message. Add that part to a Laminas\\Mime\\Message . Add additional Laminas\\Mime\\Part instances to the MIME message. Attach the MIME message as the Laminas\\Mail\\Message content body. Mark the message as multipart/related content. The following example creates a MIME message with three parts: text and HTML alternative versions of an email, and an image attachment. use Laminas\\Mail\\Message; use Laminas\\Mime\\Message as MimeMessage; use Laminas\\Mime\\Mime; use Laminas\\Mime\\Part as MimePart; $body = new MimeMessage(); $text = new MimePart($textContent); $text-&gt;type = Mime::TYPE_TEXT; $text-&gt;charset = 'utf-8'; $text-&gt;encoding = Mime::ENCODING_QUOTEDPRINTABLE; $html = new MimePart($htmlMarkup); $html-&gt;type = Mime::TYPE_HTML; $html-&gt;charset = 'utf-8'; $html-&gt;encoding = Mime::ENCODING_QUOTEDPRINTABLE; $content = new MimeMessage(); // This order is important for email clients to properly display the correct version of the content $content-&gt;setParts([$text, $html]); $contentPart = new MimePart($content-&gt;generateMessage()); $image = new MimePart(fopen($pathToImage, 'r')); $image-&gt;type = 'image/jpeg'; $image-&gt;filename = 'image-file-name.jpg'; $image-&gt;disposition = Mime::DISPOSITION_ATTACHMENT; $image-&gt;encoding = Mime::ENCODING_BASE64; $body = new MimeMessage(); $body-&gt;setParts([$contentPart, $image]); $message = new Message(); $message-&gt;setBody($body); $contentTypeHeader = $message-&gt;getHeaders()-&gt;get('Content-Type'); $contentTypeHeader-&gt;setType('multipart/related');","title":"multipart/alternative emails with attachments"},{"location":"message/attachments/#setting-custom-mime-boundaries","text":"In a multipart message, a MIME boundary for separating the different parts of the message is normally generated at random. In some cases, however, you might want to specify the MIME boundary that is used. This can be done by injecting a new Laminas\\Mime\\Mime instance into the MIME message. use Laminas\\Mime\\Mime; $mimeMessage-&gt;setMime(new Mime($customBoundary));","title":"Setting custom MIME boundaries"},{"location":"message/character-sets/","text":"Character Sets Laminas\\Mail\\Message assumes a default ASCII character set, and headers and content are quoted accordingly. If you wish to specify alternate characters sets, you will need to: Notify the Message instance of the desired character-set encoding, to ensure headers are encoded correctly. Set an appropriate Content-Type header. In multipart messages, set the character set per-part. Only in text format Character sets are only applicable for message parts in text format. Example The following example is how to use Laminas\\Mail\\Message to send a message in Japanese. use Laminas\\Mail\\Message; use Laminas\\Mime\\Message as MimeMessage; use Laminas\\Mime\\Mime; use Laminas\\Mime\\Part as MimePart; // Typically, PHP will use UTF-8 internally; the following converts // the text to a Japanese encoding. function convertToJapaneseEncoding($string) { return mb_convert_encoding($string, 'ISO-2022-JP', 'UTF-8'); } $mail = new Message(); // Set message encoding; this only affects headers. $mail-&gt;setEncoding('ISO-2022-JP'); // Set the message content type: $mail-&gt;getHeaders()-&gt;addHeaderLine('Content-Type', 'text/plain; charset=ISO-2022-JP'); // Add some headers. Textual content needs to be encoded first. $mail-&gt;setFrom('somebody@example.com', convertToJapaneseEncoding('Some Sender')); $mail-&gt;addTo('somebody_else@example.com', convertToJapaneseEncoding('Some Recipient')); $mail-&gt;setSubject(convertToJapaneseEncoding('TestSubject')); // Create a MIME part specifying 7bit encoding: $part = new MimePart(convertToJapaneseEncoding($content)); $part-&gt;encoding = Mime::ENCODING_7BIT; // Create a MIME message, add the part, and attach it to the mail message: $body = new MimeMessage(); $body-&gt;addPart($part); $mail-&gt;setBody($body);","title":"Character Sets"},{"location":"message/character-sets/#character-sets","text":"Laminas\\Mail\\Message assumes a default ASCII character set, and headers and content are quoted accordingly. If you wish to specify alternate characters sets, you will need to: Notify the Message instance of the desired character-set encoding, to ensure headers are encoded correctly. Set an appropriate Content-Type header. In multipart messages, set the character set per-part.","title":"Character Sets"},{"location":"message/character-sets/#only-in-text-format","text":"Character sets are only applicable for message parts in text format.","title":"Only in text format"},{"location":"message/character-sets/#example","text":"The following example is how to use Laminas\\Mail\\Message to send a message in Japanese. use Laminas\\Mail\\Message; use Laminas\\Mime\\Message as MimeMessage; use Laminas\\Mime\\Mime; use Laminas\\Mime\\Part as MimePart; // Typically, PHP will use UTF-8 internally; the following converts // the text to a Japanese encoding. function convertToJapaneseEncoding($string) { return mb_convert_encoding($string, 'ISO-2022-JP', 'UTF-8'); } $mail = new Message(); // Set message encoding; this only affects headers. $mail-&gt;setEncoding('ISO-2022-JP'); // Set the message content type: $mail-&gt;getHeaders()-&gt;addHeaderLine('Content-Type', 'text/plain; charset=ISO-2022-JP'); // Add some headers. Textual content needs to be encoded first. $mail-&gt;setFrom('somebody@example.com', convertToJapaneseEncoding('Some Sender')); $mail-&gt;addTo('somebody_else@example.com', convertToJapaneseEncoding('Some Recipient')); $mail-&gt;setSubject(convertToJapaneseEncoding('TestSubject')); // Create a MIME part specifying 7bit encoding: $part = new MimePart(convertToJapaneseEncoding($content)); $part-&gt;encoding = Mime::ENCODING_7BIT; // Create a MIME message, add the part, and attach it to the mail message: $body = new MimeMessage(); $body-&gt;addPart($part); $mail-&gt;setBody($body);","title":"Example"},{"location":"message/intro/","text":"Messages Laminas\\Mail\\Message encapsulates a single email message as described in RFCs 822 and 2822 . It acts as a value object for setting mail headers and content. If desired, multi-part email messages may also be created. This can be done using the laminas-mime component, and assigning the generated MIME part to the mail message body. The Message class is a value object. It is not capable of sending or storing itself; for those purposes, you will need to use, respectively, a Transport adapter or a Storage adapter . Quick Start Creating a Message by instantiating it: use Laminas\\Mail\\Message; $message = new Message(); Once you have your Message instance, you can start adding content or headers. Let's set who the mail is from, who it's addressed to, a subject, and some content: $message-&gt;addFrom('matthew@example.org', 'Matthew Somelli'); $message-&gt;addTo('foobar@example.com'); $message-&gt;setSubject('Sending an email from Laminas\\Mail!'); $message-&gt;setBody('This is the message body.'); You can also add recipients to carbon-copy (\"Cc:\") or blind carbon-copy (\"Bcc:\"). $message-&gt;addCc('ralph@example.org'); $message-&gt;addBcc('enrico@example.org'); If you want to specify an alternate address to which replies may be sent, that can be done, too. $message-&gt;addReplyTo('matthew@example.com', 'Matthew'); Interestingly, RFC-822 allows for multiple \"From:\" addresses. When you do this, the first one will be used as the sender, unless you specify a \"Sender:\" header. The Message class allows for this. /* * Mail headers created: * From: Ralph Nader &lt;ralph@example.org&gt;, Enrico Volante &lt;enrico@example.org&gt; * Sender: Matthew Sommeli &lt;matthew@example.org&gt; */ $message-&gt;addFrom('ralph@example.org', 'Ralph Nader'); $message-&gt;addFrom('enrico@example.org', 'Enrico Volante'); $message-&gt;setSender('matthew@example.org', 'Matthew Sommeli'); By default, the Message class assumes ASCII encoding for your email. If you wish to use another encoding, you can do so; setting this will ensure all headers and body content are properly encoded using quoted-printable encoding. $message-&gt;setEncoding('UTF-8'); If you wish to set other headers, you can do that as well. /* * Mail headers created: * X-API-Key: FOO-BAR-BAZ-BAT */ $message-&gt;getHeaders()-&gt;addHeaderLine('X-API-Key', 'FOO-BAR-BAZ-BAT'); Sometimes you may want to provide HTML content, or multi-part content. To do that, you'll first create a MIME message object, and then set it as the body of your mail message object. When you do so, the Message class will automatically set a \"MIME-Version\" header, as well as an appropriate \"Content-Type\" header. If you are interested in multipart emails or using attachments, read the chapter on Adding Attachments . If you want a string representation of your email, you can get that: echo $message-&gt;toString(); Finally, you can fully introspect the message, including getting all addresses of recipients and senders, all headers, and the message body. // Headers // Note: this will also grab all headers for which accessors/mutators exist in // the Message object itself. foreach ($message-&gt;getHeaders() as $header) { echo $header-&gt;toString(); // or grab values: $header-&gt;getFieldName(), $header-&gt;getFieldValue() } // The logic below also works for the methods cc(), bcc(), to(), and replyTo() foreach ($message-&gt;getFrom() as $address) { printf(\"%s: %s\\n\", $address-&gt;getEmail(), $address-&gt;getName()); } // Sender $address = $message-&gt;getSender(); if (! is_null($address)) { printf(\"%s: %s\\n\", $address-&gt;getEmail(), $address-&gt;getName()); } // Subject echo \"Subject: \", $message-&gt;getSubject(), \"\\n\"; // Encoding echo \"Encoding: \", $message-&gt;getEncoding(), \"\\n\"; // Message body: echo $message-&gt;getBody(); // raw body, or MIME object echo $message-&gt;getBodyText(); // body as it will be sent Once your message is shaped to your liking, pass it to a mail transport in order to send it! $transport-&gt;send($message); Configuration Options The Message class has no configuration options, and is instead a value object. Available Methods isValid isValid() : bool Messages without a From address are invalid, per RFC-2822. setEncoding setEncoding(string $encoding) : void Set the message encoding. getEncoding getEncoding() : string Get the message encoding. setHeaders setHeaders(Laminas\\Mail\\Headers $headers) : void Compose headers. getHeaders getHeaders() : Laminas\\Mail\\Headers Access headers collection, lazy-loading a Headers instance if none was previously attached. setFrom setFrom( string|AddressInterface|array|AddressList|Traversable $emailOrAddressList, string|null $name ) : void Set (overwrite) From addresses. If an associative array is provided, it must be a set of key/value pairs where the key is the human readable name, and the value is the email address. addFrom addFrom( string|AddressInterface|array|AddressList|Traversable $emailOrAddressOrList, string|null $name ) : void Add a From address. If an associative array is provided, it must be a set of key/value pairs where the key is the human readable name, and the value is the email address. getFrom getFrom() : AddressList Retrieve list of From senders. setTo setTo( string|AddressInterface|array|AddressList|Traversable $emailOrAddressList, null|string $name ) : void Overwrite the address list in the To recipients. If an associative array is provided, it must be a set of key/value pairs where the key is the human readable name, and the value is the email address. addTo addTo( string|AddressInterface|array|AddressList|Traversable $emailOrAddressOrList, null|string $name ) : void Add one or more addresses to the To recipients; appends to the list. If an associative array is provided, it must be a set of key/value pairs where the key is the human readable name, and the value is the email address. getTo getTo() : AddressList Access the address list of the To header. Lazy-loads an AddressList and populates the To header if not previously done. setCc setCc( string|AddressInterface|array|AddressList|Traversable $emailOrAddressList, string|null $name ) : void Set (overwrite) Cc addresses. If an associative array is provided, it must be a set of key/value pairs where the key is the human readable name, and the value is the email address. addCc addCc( string|AddressInterface|array|AddressList|Traversable $emailOrAddressList, string|null $name ) : void Add a Cc address. If an associative array is provided, it must be a set of key/value pairs where the key is the human readable name, and the value is the email address. getCc getCc() : AddressList Retrieve list of Cc recipients. Lazy-loads an AddressList and populates the Cc header if not previously done. setBcc setBcc( string|AddressInterface|array|AddressList|Traversable $emailOrAddressList, string|null $name ) : void Set (overwrite) Bcc addresses. If an associative array is provided, it must be a set of key/value pairs where the key is the human readable name, and the value is the email address. addBcc addBcc( string|AddressInterface|array|AddressList|Traversable $emailOrAddressList, string|null $name ) : void Add a Bcc address. If an associative array is provided, it must be a set of key/value pairs where the key is the human readable name, and the value is the email address. getBcc getBcc() : AddressList Retrieve list of Bcc recipients. Lazy-loads an AddressList and populates the Bcc header if not previously done. setReplyTo setReplyTo( string|AddressInterface|array|AddressList|Traversable $emailOrAddressList, string|null $name ) : void Overwrite the address list in the Reply-To recipients. If an associative array is provided, it must be a set of key/value pairs where the key is the human readable name, and the value is the email address. addReplyTo addReplyTo( string|AddressInterface|array|AddressList|Traversable $emailOrAddressList, string|null $name ) : void Add one or more addresses to the Reply-To recipients. If an associative array is provided, it must be a set of key/value pairs where the key is the human readable name, and the value is the email address. getReplyTo getReplyTo() : AddressList Access the address list of the Reply-To header. Lazy-loads an AddressList and populates the Reply-To header if not previously done. setSender setSender( string|AddressInterface $emailOrAddress, null|string $name ) : void Set the message envelope Sender header. getSender getSender() : null|AddressInterface Retrieve the sender address, if any. setSubject setSubject(string $subject) :void Set the message subject header value. getSubject getSubject() : null|string Get the message subject header value. setBody setBody(null|string|Laminas\\Mime\\Message|object $body) : void Set the message body. If a generic object is provided, it must implement __toString() . getBody getBody() : null|string|object Return the currently set message body. Object return values include Laminas\\Mime\\Message instances or objects implementing __toString() . getBodyText getBodyText() : null|string Get the string-serialized message body text. toString toString() : string Serialize to string.","title":"Intro and Usage"},{"location":"message/intro/#messages","text":"Laminas\\Mail\\Message encapsulates a single email message as described in RFCs 822 and 2822 . It acts as a value object for setting mail headers and content. If desired, multi-part email messages may also be created. This can be done using the laminas-mime component, and assigning the generated MIME part to the mail message body. The Message class is a value object. It is not capable of sending or storing itself; for those purposes, you will need to use, respectively, a Transport adapter or a Storage adapter .","title":"Messages"},{"location":"message/intro/#quick-start","text":"Creating a Message by instantiating it: use Laminas\\Mail\\Message; $message = new Message(); Once you have your Message instance, you can start adding content or headers. Let's set who the mail is from, who it's addressed to, a subject, and some content: $message-&gt;addFrom('matthew@example.org', 'Matthew Somelli'); $message-&gt;addTo('foobar@example.com'); $message-&gt;setSubject('Sending an email from Laminas\\Mail!'); $message-&gt;setBody('This is the message body.'); You can also add recipients to carbon-copy (\"Cc:\") or blind carbon-copy (\"Bcc:\"). $message-&gt;addCc('ralph@example.org'); $message-&gt;addBcc('enrico@example.org'); If you want to specify an alternate address to which replies may be sent, that can be done, too. $message-&gt;addReplyTo('matthew@example.com', 'Matthew'); Interestingly, RFC-822 allows for multiple \"From:\" addresses. When you do this, the first one will be used as the sender, unless you specify a \"Sender:\" header. The Message class allows for this. /* * Mail headers created: * From: Ralph Nader &lt;ralph@example.org&gt;, Enrico Volante &lt;enrico@example.org&gt; * Sender: Matthew Sommeli &lt;matthew@example.org&gt; */ $message-&gt;addFrom('ralph@example.org', 'Ralph Nader'); $message-&gt;addFrom('enrico@example.org', 'Enrico Volante'); $message-&gt;setSender('matthew@example.org', 'Matthew Sommeli'); By default, the Message class assumes ASCII encoding for your email. If you wish to use another encoding, you can do so; setting this will ensure all headers and body content are properly encoded using quoted-printable encoding. $message-&gt;setEncoding('UTF-8'); If you wish to set other headers, you can do that as well. /* * Mail headers created: * X-API-Key: FOO-BAR-BAZ-BAT */ $message-&gt;getHeaders()-&gt;addHeaderLine('X-API-Key', 'FOO-BAR-BAZ-BAT'); Sometimes you may want to provide HTML content, or multi-part content. To do that, you'll first create a MIME message object, and then set it as the body of your mail message object. When you do so, the Message class will automatically set a \"MIME-Version\" header, as well as an appropriate \"Content-Type\" header. If you are interested in multipart emails or using attachments, read the chapter on Adding Attachments . If you want a string representation of your email, you can get that: echo $message-&gt;toString(); Finally, you can fully introspect the message, including getting all addresses of recipients and senders, all headers, and the message body. // Headers // Note: this will also grab all headers for which accessors/mutators exist in // the Message object itself. foreach ($message-&gt;getHeaders() as $header) { echo $header-&gt;toString(); // or grab values: $header-&gt;getFieldName(), $header-&gt;getFieldValue() } // The logic below also works for the methods cc(), bcc(), to(), and replyTo() foreach ($message-&gt;getFrom() as $address) { printf(\"%s: %s\\n\", $address-&gt;getEmail(), $address-&gt;getName()); } // Sender $address = $message-&gt;getSender(); if (! is_null($address)) { printf(\"%s: %s\\n\", $address-&gt;getEmail(), $address-&gt;getName()); } // Subject echo \"Subject: \", $message-&gt;getSubject(), \"\\n\"; // Encoding echo \"Encoding: \", $message-&gt;getEncoding(), \"\\n\"; // Message body: echo $message-&gt;getBody(); // raw body, or MIME object echo $message-&gt;getBodyText(); // body as it will be sent Once your message is shaped to your liking, pass it to a mail transport in order to send it! $transport-&gt;send($message);","title":"Quick Start"},{"location":"message/intro/#configuration-options","text":"The Message class has no configuration options, and is instead a value object.","title":"Configuration Options"},{"location":"message/intro/#available-methods","text":"","title":"Available Methods"},{"location":"transport/file-options/","text":"File Transport Options This document details the various options available to the Laminas\\Mail\\Transport\\File mail transport. Quick Start use Laminas\\Mail\\Transport\\File as FileTransport; use Laminas\\Mail\\Transport\\FileOptions; // Setup File transport $transport = new FileTransport(); $options = new FileOptions([ 'path' =&gt; 'data/mail/', 'callback' =&gt; function (FileTransport $transport) { return 'Message_' . microtime(true) . '_' . mt_rand() . '.txt'; }, ]); $transport-&gt;setOptions($options); Configuration Options Option name Description path The path under which mail files will be written. callback A PHP callable to be invoked in order to generate a unique name for a message file. See below for the default used. The default callback used is: function (Laminas\\Mail\\FileTransport $transport) { return 'LaminasMail_' . time() . '_' . mt_rand() . '.tmp'; } Available Methods Laminas\\Mail\\Transport\\FileOptions extends Laminas\\Stdlib\\AbstractOptions , and inherits all functionality from that class; this includes property overloading. Additionally, the following explicit setters and getters are provided. setPath setPath(string $path) : void Set the path under which mail files will be written. getPath getPath() : string Get the path under which mail files will be written. setCallback setCallback(callable $callback) : void Set the callback used to generate unique filenames for messages. getCallback getCallback() : callable Get the callback used to generate unique filenames for messages. __construct __construct(null|array|Traversable $config) : void Initialize the object. Allows passing a PHP array or Traversable object with which to populate the instance.","title":"File Transport Options"},{"location":"transport/file-options/#file-transport-options","text":"This document details the various options available to the Laminas\\Mail\\Transport\\File mail transport.","title":"File Transport Options"},{"location":"transport/file-options/#quick-start","text":"use Laminas\\Mail\\Transport\\File as FileTransport; use Laminas\\Mail\\Transport\\FileOptions; // Setup File transport $transport = new FileTransport(); $options = new FileOptions([ 'path' =&gt; 'data/mail/', 'callback' =&gt; function (FileTransport $transport) { return 'Message_' . microtime(true) . '_' . mt_rand() . '.txt'; }, ]); $transport-&gt;setOptions($options);","title":"Quick Start"},{"location":"transport/file-options/#configuration-options","text":"Option name Description path The path under which mail files will be written. callback A PHP callable to be invoked in order to generate a unique name for a message file. See below for the default used. The default callback used is: function (Laminas\\Mail\\FileTransport $transport) { return 'LaminasMail_' . time() . '_' . mt_rand() . '.tmp'; }","title":"Configuration Options"},{"location":"transport/file-options/#available-methods","text":"Laminas\\Mail\\Transport\\FileOptions extends Laminas\\Stdlib\\AbstractOptions , and inherits all functionality from that class; this includes property overloading. Additionally, the following explicit setters and getters are provided.","title":"Available Methods"},{"location":"transport/intro/","text":"Transports Transports take care of the actual delivery of mail. Typically, you only need to worry about two possibilities: using PHP's native mail() functionality, which uses system resources to deliver mail, or using the SMTP protocol for delivering mail via a remote server. Laminas also includes a \"File\" transport, which creates a mail file for each message sent; these can later be introspected as logs or consumed for the purposes of sending via an alternate transport mechanism later. The Laminas\\Mail\\Transport interface defines exactly one method, send() . This method accepts a Laminas\\Mail\\Message instance, which it then introspects and serializes in order to send. Quick Start Using a mail transport involves instantiating it, optionally configuring it, and then passing a message to it. Sendmail Transport Usage use Laminas\\Mail\\Message; use Laminas\\Mail\\Transport\\Sendmail as SendmailTransport; $message = new Message(); $message-&gt;addTo('matthew@example.org'); $message-&gt;addFrom('ralph@example.org'); $message-&gt;setSubject('Greetings and Salutations!'); $message-&gt;setBody(\"Sorry, I'm going to be late today!\"); $transport = new SendmailTransport(); $transport-&gt;send($message); SMTP Transport Usage Installation requirements The SMTP transport depends on the laminas-servicemanager component, so be sure to have it installed before getting started: $ composer require laminas/laminas-servicemanager use Laminas\\Mail\\Message; use Laminas\\Mail\\Transport\\Smtp as SmtpTransport; use Laminas\\Mail\\Transport\\SmtpOptions; $message = new Message(); $message-&gt;addTo('matthew@example.org'); $message-&gt;addFrom('ralph@example.org'); $message-&gt;setSubject('Greetings and Salutations!'); $message-&gt;setBody(\"Sorry, I'm going to be late today!\"); // Setup SMTP transport using LOGIN authentication $transport = new SmtpTransport(); $options = new SmtpOptions([ 'name' =&gt; 'localhost.localdomain', 'host' =&gt; '127.0.0.1', 'connection_class' =&gt; 'login', 'connection_config' =&gt; [ 'username' =&gt; 'user', 'password' =&gt; 'pass', ], ]); $transport-&gt;setOptions($options); $transport-&gt;send($message); File Transport Usage use Laminas\\Mail\\Message; use Laminas\\Mail\\Transport\\File as FileTransport; use Laminas\\Mail\\Transport\\FileOptions; use Laminas\\Math\\Rand; $message = new Message(); $message-&gt;addTo('matthew@example.org'); $message-&gt;addFrom('ralph@example.org'); $message-&gt;setSubject('Greetings and Salutations!'); $message-&gt;setBody(\"Sorry, I'm going to be late today!\"); // Setup File transport $transport = new FileTransport(); $options = new FileOptions([ 'path' =&gt; 'data/mail/', 'callback' =&gt; function (FileTransport $transport) { return sprintf( 'Message_%f_%s.txt', microtime(true), Rand::getString(8) ); }, ]); $transport-&gt;setOptions($options); $transport-&gt;send($message); InMemory Transport Usage use Laminas\\Mail\\Message; use Laminas\\Mail\\Transport\\InMemory as InMemoryTransport; $message = new Message(); $message-&gt;addTo('matthew@example.org'); $message-&gt;addFrom('ralph@example.org'); $message-&gt;setSubject('Greetings and Salutations!'); $message-&gt;setBody(\"Sorry, I'm going to be late today!\"); // Setup InMemory transport $transport = new InMemoryTransport(); $transport-&gt;send($message); // Verify the message: $received = $transport-&gt;getLastMessage(); The InMemory transport is primarily of interest when in development or when testing. Migration from 2.0-2.3 to 2.4+ Version 2.4 adds support for PHP 7. In PHP 7, null is a reserved keyword, which required renaming the Null transport. If you were using the Null transport directly previously, you will now receive an E_USER_DEPRECATED notice on instantiation. Please update your code to refer to the InMemory class instead. Users pulling their Null transport instance from the transport factory ( Laminas\\Mail\\Transport\\Factory ) receive an InMemory instance instead starting in 2.4.0. Configuration Options Configuration options are per transport. Please follow the links below for transport-specific options. SMTP Transport Options File Transport Options Available Methods send send(Laminas\\Mail\\Message $message) : void Send a mail message.","title":"Usage"},{"location":"transport/intro/#transports","text":"Transports take care of the actual delivery of mail. Typically, you only need to worry about two possibilities: using PHP's native mail() functionality, which uses system resources to deliver mail, or using the SMTP protocol for delivering mail via a remote server. Laminas also includes a \"File\" transport, which creates a mail file for each message sent; these can later be introspected as logs or consumed for the purposes of sending via an alternate transport mechanism later. The Laminas\\Mail\\Transport interface defines exactly one method, send() . This method accepts a Laminas\\Mail\\Message instance, which it then introspects and serializes in order to send.","title":"Transports"},{"location":"transport/intro/#quick-start","text":"Using a mail transport involves instantiating it, optionally configuring it, and then passing a message to it.","title":"Quick Start"},{"location":"transport/intro/#configuration-options","text":"Configuration options are per transport. Please follow the links below for transport-specific options. SMTP Transport Options File Transport Options","title":"Configuration Options"},{"location":"transport/intro/#available-methods","text":"","title":"Available Methods"},{"location":"transport/smtp-authentication/","text":"SMTP Authentication laminas-mail supports the use of SMTP authentication, which can be enabled via configuration. The available built-in authentication methods are PLAIN, LOGIN, and CRAM-MD5, all of which expect 'username' and 'password' values in the configuration array. Configuration In order to enable authentication, ou need to specify a \"connection class\" and connection configuration when configuring your SMTP transport. The two settings are briefly covered in the SMTP transport configuration options . Below are more details. connection_class The connection class should be a fully qualified class name of a Laminas\\Mail\\Protocol\\Smtp\\Auth\\* class or extension, or the short name (name without leading namespace). laminas-mail ships with the following: Laminas\\Mail\\Protocol\\Smtp\\Auth\\Plain , or plain Laminas\\Mail\\Protocol\\Smtp\\Auth\\Login , or login Laminas\\Mail\\Protocol\\Smtp\\Auth\\Crammd5 , or crammd5 Custom connection classes must be extensions of Laminas\\Mail\\Protocol\\Smtp . connection_config The connection_config should be an associative array of options to provide to the underlying connection class. All shipped connection classes require: username password Optionally, ou may also provide: ssl : either the value ssl or tls . port : if using something other than the default port for the protocol used. Port 25 is the default used for non-SSL connections, 465 for SSL, and 587 for TLS. use_complete_quit : configuring whether or not an SMTP transport should issue a QUIT at __destruct() and/or end of script execution. Useful in long-running scripts against SMTP servers that implements a reuse time limit . Examples SMTP Transport Usage with PLAIN AUTH use Laminas\\Mail\\Transport\\Smtp as SmtpTransport; use Laminas\\Mail\\Transport\\SmtpOptions; // Setup SMTP transport using PLAIN authentication $transport = new SmtpTransport(); $options = new SmtpOptions([ 'name' =&gt; 'localhost.localdomain', 'host' =&gt; '127.0.0.1', 'connection_class' =&gt; 'plain', 'connection_config' =&gt; [ 'username' =&gt; 'user', 'password' =&gt; 'pass', ], ]); $transport-&gt;setOptions($options); SMTP Transport Usage with LOGIN AUTH use Laminas\\Mail\\Transport\\Smtp as SmtpTransport; use Laminas\\Mail\\Transport\\SmtpOptions; // Setup SMTP transport using LOGIN authentication $transport = new SmtpTransport(); $options = new SmtpOptions([ 'name' =&gt; 'localhost.localdomain', 'host' =&gt; '127.0.0.1', 'connection_class' =&gt; 'login', 'connection_config' =&gt; [ 'username' =&gt; 'user', 'password' =&gt; 'pass', ], ]); $transport-&gt;setOptions($options); SMTP Transport Usage with CRAM-MD5 AUTH Installation requirements The CRAM-MD5 authentication depends on the laminas-crypt component, so be sure to have it installed before getting started: $ composer require laminas/laminas-crypt use Laminas\\Mail\\Transport\\Smtp as SmtpTransport; use Laminas\\Mail\\Transport\\SmtpOptions; // Setup SMTP transport using CRAM-MD5 authentication $transport = new SmtpTransport(); $options = new SmtpOptions([ 'name' =&gt; 'localhost.localdomain', 'host' =&gt; '127.0.0.1', 'connection_class' =&gt; 'crammd5', 'connection_config' =&gt; [ 'username' =&gt; 'user', 'password' =&gt; 'pass', ], ]); $transport-&gt;setOptions($options); SMTP Transport Usage with PLAIN AUTH over TLS use Laminas\\Mail\\Transport\\Smtp as SmtpTransport; use Laminas\\Mail\\Transport\\SmtpOptions; // Setup SMTP transport using PLAIN authentication over TLS $transport = new SmtpTransport(); $options = new SmtpOptions([ 'name' =&gt; 'example.com', 'host' =&gt; '127.0.0.1', 'port' =&gt; 587, // Notice port change for TLS is 587 'connection_class' =&gt; 'plain', 'connection_config' =&gt; [ 'username' =&gt; 'user', 'password' =&gt; 'pass', 'ssl' =&gt; 'tls', ], ]); $transport-&gt;setOptions($options); SMTP Transport Usage for servers with reuse time limit By default, every Laminas\\Mail\\Protocol\\Smtp\\* class tries to disconnect from the STMP server by sending a QUIT command and expecting a 221 ( Service closing transmission channel ) response code. This is done automatically at object destruction (via the __destruct() method), and can generate errors with SMTP servers like Postfix that implement a reuse time limit: // [...] $transport-&gt;send($message); var_dump('E-mail sent'); sleep(305); var_dump('Soon to exit...'); exit; // E-mail sent // Soon to exit... // Notice: fwrite(): send of 6 bytes failed with errno=32 Broken pipe in ./laminas-mail/src/Protocol/AbstractProtocol.php on line 255 // Fatal error: Uncaught Laminas\\Mail\\Protocol\\Exception\\RuntimeException: Could not read from 127.0.0.1 in ./laminas-mail/src/Protocol/AbstractProtocol.php:301 To avoid this error, you can set a time limit for the SMTP connection in SmtpOptions : use Laminas\\Mail\\Transport\\Smtp as SmtpTransport; use Laminas\\Mail\\Transport\\SmtpOptions; // Setup SMTP transport to exit without the `QUIT` command $transport = new SmtpTransport(); $options = new SmtpOptions([ 'name' =&gt; 'localhost.localdomain', 'host' =&gt; '127.0.0.1', 'connection_time_limit' =&gt; 300, // recreate the connection 5 minutes after connect() 'connection_class' =&gt; 'plain', 'connection_config' =&gt; [ 'username' =&gt; 'user', 'password' =&gt; 'pass', 'use_complete_quit' =&gt; false, // Dont send 'QUIT' on __destruct() ], ]); $transport-&gt;setOptions($options); Setting connection_time_limit will automatically set use_complete_quit to false , so the connection with the SMTP server will be closed without the QUIT command. NOTE: recreate old connection The use_complete_quit flag described above aims to avoid errors that you cannot manage from PHP. If you deal with SMTP servers that exhibit this behavior from within long-running scripts, you SHOULD use the flag along with the connection_time_limit flag to ensure you recreate the connection. Since 2.10.0 The connection_time_limit flag has been available since 2.10.0.","title":"Authentication"},{"location":"transport/smtp-authentication/#smtp-authentication","text":"laminas-mail supports the use of SMTP authentication, which can be enabled via configuration. The available built-in authentication methods are PLAIN, LOGIN, and CRAM-MD5, all of which expect 'username' and 'password' values in the configuration array.","title":"SMTP Authentication"},{"location":"transport/smtp-authentication/#configuration","text":"In order to enable authentication, ou need to specify a \"connection class\" and connection configuration when configuring your SMTP transport. The two settings are briefly covered in the SMTP transport configuration options . Below are more details.","title":"Configuration"},{"location":"transport/smtp-authentication/#examples","text":"","title":"Examples"},{"location":"transport/smtp-multiple-send/","text":"Sending Multiple Mails per SMTP Connection By default, a single SMTP transport creates a single connection and re-uses it for the lifetime of the script execution. You may send multiple e-mails through this SMTP connection. A RSET command is issued before each delivery to ensure the correct SMTP handshake is followed. Examples Sending Multiple Mails per SMTP Connection use Laminas\\Mail\\Message; use Laminas\\Mail\\Transport\\Smtp; // Create transport $transport = new Smtp([ 'host' =&gt; 'mail.example.com' ]); // Create a base message: $message = (new Message()) -&gt;addFrom('sender@example.com', 'John Doe') -&gt;addReplyTo('replyto@example.com', 'Jane Doe') -&gt;setSubject('Demo of multiple mails per SMTP connection') -&gt;setBody('... Your message here ...'); // Loop through recipients: foreach ($recipients as $address) { $message-&gt;setTo($address); $transport-&gt;send($message); } If you wish to have a separate connection for each mail delivery, you will need to create and destroy your transport before and after each send() method is called. Manipulating the transport between messages You can manipulate the connection between each delivery by accessing the transport's protocol object. use Laminas\\Mail\\Message; use Laminas\\Mail\\Protocol\\Smtp as SmtpProtocol; use Laminas\\Mail\\Transport\\Smtp as SmtpTransport; // Create transport $transport = new SmtpTransport(); $protocol = new SmtpProtocol('mail.example.com'); $protocol-&gt;connect(); $protocol-&gt;helo('sender.example.com'); $transport-&gt;setConnection($protocol); // Loop through messages foreach ($recipients as $address) { $mail = new Message(); $mail-&gt;addTo($address); $mail-&gt;setFrom('studio@example.com', 'Test'); $mail-&gt;setSubject( 'Demonstration - Sending Multiple Mails per SMTP Connection' ); $mail-&gt;setBodyText('...Your message here...'); // Manually control the connection $protocol-&gt;rset(); $transport-&gt;send($message); } $protocol-&gt;quit(); $protocol-&gt;disconnect();","title":"Sending multiple messages"},{"location":"transport/smtp-multiple-send/#sending-multiple-mails-per-smtp-connection","text":"By default, a single SMTP transport creates a single connection and re-uses it for the lifetime of the script execution. You may send multiple e-mails through this SMTP connection. A RSET command is issued before each delivery to ensure the correct SMTP handshake is followed.","title":"Sending Multiple Mails per SMTP Connection"},{"location":"transport/smtp-multiple-send/#examples","text":"","title":"Examples"},{"location":"transport/smtp-options/","text":"SMTP Transport Options This document details the various options available to the Laminas\\Mail\\Transport\\Smtp mail transport. Quick Start Basic SMTP Transport Usage use Laminas\\Mail\\Transport\\Smtp as SmtpTransport; use Laminas\\Mail\\Transport\\SmtpOptions; // Setup SMTP transport $transport = new SmtpTransport(); $options = new SmtpOptions([ 'name' =&gt; 'localhost.localdomain', 'host' =&gt; '127.0.0.1', 'port' =&gt; 25, ]); $transport-&gt;setOptions($options); If you require authentication, see the section on SMTP authentication for examples of configuring authentication credentials. Configuration Options Option name Description name Name of the SMTP host; defaults to \"localhost\". host Remote hostname or IP address; defaults to \"127.0.0.1\". port Port on which the remote host is listening; defaults to \"25\". connection_class Fully-qualified classname or short name resolvable via Laminas\\Mail\\Protocol\\SmtpPluginManager . See the SMTP authentication documentation for details. connection_config Optional associative array of parameters to pass to the connection class in order to configure it. By default, this is empty. See the SMTP authentication documentation for details. Available Methods getName getName() : string Returns the string name of the local client hostname. setName setName(string $name) : void Set the string name of the local client hostname. getConnectionClass getConnectionClass() : string Returns a string indicating the connection class name to use. setConnectionClass setConnectionClass(string $connectionClass) : void Set the connection class to use. getConnectionConfig getConnectionConfig() : array Get configuration for the connection class. setConnectionConfig setConnectionConfig(array $config) : void Set configuration for the connection class. Typically, if using anything other than the default connection class, this will be an associative array with the keys \"username\" and \"password\". getHost getHost() : string Returns a string indicating the IP address or host name of the SMTP server via which to send messages. setHost setHost(string $host) : void Set the SMTP host name or IP address. getPort getPort() : int Retrieve the integer port on which the SMTP host is listening. setPort setPort(int $port) : void Set the port on which the SMTP host is listening. __construct __construct(null|array|Traversable $config) : void Instantiate the class, and optionally configure it with values provided.","title":"SMTP Options"},{"location":"transport/smtp-options/#smtp-transport-options","text":"This document details the various options available to the Laminas\\Mail\\Transport\\Smtp mail transport.","title":"SMTP Transport Options"},{"location":"transport/smtp-options/#quick-start","text":"","title":"Quick Start"},{"location":"transport/smtp-options/#configuration-options","text":"Option name Description name Name of the SMTP host; defaults to \"localhost\". host Remote hostname or IP address; defaults to \"127.0.0.1\". port Port on which the remote host is listening; defaults to \"25\". connection_class Fully-qualified classname or short name resolvable via Laminas\\Mail\\Protocol\\SmtpPluginManager . See the SMTP authentication documentation for details. connection_config Optional associative array of parameters to pass to the connection class in order to configure it. By default, this is empty. See the SMTP authentication documentation for details.","title":"Configuration Options"},{"location":"transport/smtp-options/#available-methods","text":"","title":"Available Methods"}]}